import { useContext, useEffect, useRef, useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { Link } from "react-router-dom";
import { deletePost, likePost, savePost } from "../../actions/postAction";
import {
  BASE_POST_IMAGE_URL,
  BASE_PROFILE_IMAGE_URL,
} from "../../utils/constants";
import { likeFill } from "../Navbar/SvgIcons";
import {
  commentIcon,
  emojiIcon,
  likeIconOutline,
  moreIcons,
  saveIconFill,
  saveIconOutline,
  shareIcon,
} from "./SvgIcons";
import { Picker } from "emoji-mart";
import ScrollToBottom from "react-scroll-to-bottom";
import axios from "axios";
import moment from "moment";
import { Dialog } from "@mui/material";
import { AppContext } from "../../context/AppContext";

// Component hi·ªÉn th·ªã b√¨nh lu·∫≠n
const CommentItem = ({
  comment,
  postId,
  level = 0,
  onReplySubmit,
  onCommentDeleted,
}) => {
  const dispatch = useDispatch();
  const { user } = useSelector((state) => state.user);
  const { socket } = useContext(AppContext);

  const [showReplyForm, setShowReplyForm] = useState(false);
  const [replyContent, setReplyContent] = useState("");
  const [showChildComments, setShowChildComments] = useState(false);
  const [childComments, setChildComments] = useState([]);
  const [loadingChildren, setLoadingChildren] = useState(false);
  const [showEmojis, setShowEmojis] = useState(false);
  const [liked, setLiked] = useState(false);
  const [likeCount, setLikeCount] = useState(
    comment.comment_likes ? comment.comment_likes.length : 0,
  );
  const [deleteDialog, setDeleteDialog] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    // Ki·ªÉm tra xem ng∆∞·ªùi d√πng hi·ªán t·∫°i ƒë√£ th√≠ch b√¨nh lu·∫≠n n√†y ch∆∞a
    if (comment.comment_likes) {
      setLiked(comment.comment_likes.includes(user._id));
      setLikeCount(comment.comment_likes.length);
    }
  }, [comment.comment_likes, user._id]);

  const handleReplySubmit = async (e) => {
    e.preventDefault();
    if (!replyContent.trim() || isSubmitting) return;

    setIsSubmitting(true);
    console.log("ƒêang g·ª≠i b√¨nh lu·∫≠n tr·∫£ l·ªùi cho:", comment._id);

    try {
      const success = await onReplySubmit(replyContent, comment._id);

      if (success) {
        setReplyContent("");
        setShowReplyForm(false);
        // Th√™m timeout ƒë·ªÉ ƒë·∫£m b·∫£o server ƒë√£ x·ª≠ l√Ω xong
        setTimeout(() => {
          loadChildComments();
        }, 500);
      }
    } catch (error) {
      console.error("L·ªói khi g·ª≠i b√¨nh lu·∫≠n tr·∫£ l·ªùi:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const loadChildComments = async () => {
    setLoadingChildren(true);
    try {
      console.log("ƒêang t·∫£i b√¨nh lu·∫≠n con cho comment ID:", comment._id);
      const response = await axios.get(
        `/api/v1/comments/${postId}/parent?parentId=${comment._id}`,
      );

      if (response.data.success) {
        const uniqueComments = [];
        const commentIds = new Set();

        response.data.comments.forEach((comment) => {
          if (!commentIds.has(comment._id)) {
            commentIds.add(comment._id);
            uniqueComments.push(comment);
          }
        });

        setChildComments(uniqueComments);
        setShowChildComments(true);
      }
    } catch (error) {
      console.error("L·ªói khi t·∫£i b√¨nh lu·∫≠n con:", error);
    } finally {
      setLoadingChildren(false);
    }
  };

  // Ki·ªÉm tra n·∫øu comment c√≥ th·ªÉ c√≥ replies d·ª±a tr√™n left v√† right
  const hasChildren = comment.comment_right - comment.comment_left > 1;

  const toggleChildComments = () => {
    if (showChildComments) {
      setShowChildComments(false);
    } else {
      loadChildComments();
    }
  };

  // H√†m x·ª≠ l√Ω th√≠ch/b·ªè th√≠ch b√¨nh lu·∫≠n
  const handleLikeComment = async () => {
    try {
      const wasLiked = !liked; // L∆∞u tr·∫°ng th√°i tr∆∞·ªõc khi c·∫≠p nh·∫≠t UI
      setLiked(!liked); // C·∫≠p nh·∫≠t UI ngay l·∫≠p t·ª©c ƒë·ªÉ ph·∫£n h·ªìi ng∆∞·ªùi d√πng
      setLikeCount(liked ? likeCount - 1 : likeCount + 1);

      const response = await axios.post(`/api/v1/comment/${comment._id}/like`);

      if (response.data.success) {
        // C·∫≠p nh·∫≠t l·∫°i state d·ª±a tr√™n ph·∫£n h·ªìi t·ª´ server
        setLiked(response.data.isLiked);
        setLikeCount(response.data.likeCount);

        // G·ª≠i th√¥ng b√°o qua socket n·∫øu l√† like (kh√¥ng ph·∫£i unlike)
        // v√† ng∆∞·ªùi like kh√¥ng ph·∫£i ch·ªß comment
        if (
          socket?.current &&
          response.data.isLiked &&
          comment.comment_userId._id !== user._id
        ) {
          socket.current.emit("likeComment", {
            commentId: comment._id,
            postId: postId,
            likerId: user._id,
            commentOwnerId: comment.comment_userId._id,
            likerName: user.username || user.name,
          });
        }
      }
    } catch (error) {
      // N·∫øu c√≥ l·ªói, ho√†n t√°c thay ƒë·ªïi UI
      setLiked(!liked);
      setLikeCount(liked ? likeCount + 1 : likeCount - 1);
      console.error("L·ªói khi th√≠ch/b·ªè th√≠ch b√¨nh lu·∫≠n:", error);
    }
  };

  // H√†m x·ª≠ l√Ω x√≥a b√¨nh lu·∫≠n
  const handleDeleteComment = async () => {
    try {
      const response = await axios.delete(`/api/v1/comment/${comment._id}`, {
        data: { postId: postId },
      });

      if (response.data.success) {
        // Th√¥ng b√°o cho component cha bi·∫øt b√¨nh lu·∫≠n ƒë√£ b·ªã x√≥a
        onCommentDeleted(comment._id);
      }
    } catch (error) {
      console.error("L·ªói khi x√≥a b√¨nh lu·∫≠n:", error);
    } finally {
      setDeleteDialog(false);
    }
  };

  // Ki·ªÉm tra quy·ªÅn x√≥a b√¨nh lu·∫≠n
  const canDelete = user._id === comment.comment_userId._id;

  return (
    <div
      className={`mb-3 ${level > 0 ? "border-l-2 border-gray-200 pl-4 ml-4" : ""}`}
    >
      <div className="flex items-start space-x-2">
        <img
          draggable="false"
          className="h-7 w-7 rounded-full object-cover mr-0.5"
          src={BASE_PROFILE_IMAGE_URL + comment.comment_userId.avatar}
          alt="avatar"
        />
        <div className="flex flex-col flex-1">
          <div className="flex items-start">
            <Link
              to={`/${comment.comment_userId.username}`}
              className="text-sm font-semibold hover:underline mr-2"
            >
              {comment.comment_userId.username}
            </Link>
            <p className="text-sm">{comment.comment_content}</p>
          </div>

          <div className="flex space-x-4 mt-1 text-xs text-gray-500">
            <span>{moment(comment.createdAt).fromNow()}</span>

            <div className="flex items-center space-x-1">
              <button
                onClick={handleLikeComment}
                className="focus:outline-none"
              >
                {liked ? (
                  <span className="text-red-500">‚ù§Ô∏è</span>
                ) : (
                  <span>ü§ç</span>
                )}
              </button>
              {likeCount > 0 && <span>{likeCount}</span>}
            </div>

            <button
              onClick={() => setShowReplyForm(!showReplyForm)}
              className="font-semibold hover:text-gray-700"
            >
              Tr·∫£ l·ªùi
            </button>

            {hasChildren && (
              <button
                onClick={toggleChildComments}
                className="font-semibold hover:text-gray-700"
              >
                {showChildComments ? "·∫®n tr·∫£ l·ªùi" : "Xem tr·∫£ l·ªùi"}
              </button>
            )}

            {/* N√∫t x√≥a b√¨nh lu·∫≠n */}
            {canDelete && (
              <button
                onClick={() => setDeleteDialog(true)}
                className="font-semibold text-red-500 hover:text-red-700"
              >
                X√≥a
              </button>
            )}
          </div>

          {/* Dialog x√°c nh·∫≠n x√≥a b√¨nh lu·∫≠n */}
          <Dialog
            open={deleteDialog}
            onClose={() => setDeleteDialog(false)}
            maxWidth="xs"
          >
            <div className="flex flex-col items-center p-4 w-64">
              <h3 className="mb-4 text-lg font-medium">X√≥a b√¨nh lu·∫≠n?</h3>
              <p className="mb-4 text-sm text-gray-500">
                B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a b√¨nh lu·∫≠n n√†y kh√¥ng?
              </p>
              <div className="flex w-full space-x-2">
                <button
                  onClick={handleDeleteComment}
                  className="w-1/2 py-2 text-white bg-red-500 rounded hover:bg-red-600"
                >
                  X√≥a
                </button>
                <button
                  onClick={() => setDeleteDialog(false)}
                  className="w-1/2 py-2 text-gray-700 bg-gray-100 rounded hover:bg-gray-200"
                >
                  H·ªßy
                </button>
              </div>
            </div>
          </Dialog>

          {showReplyForm && (
            <form onSubmit={handleReplySubmit} className="mt-2 flex">
              <span
                onClick={() => setShowEmojis(!showEmojis)}
                className="cursor-pointer mr-2"
              >
                {emojiIcon}
              </span>

              {showEmojis && (
                <div className="absolute z-10">
                  <Picker
                    set="google"
                    onSelect={(e) => setReplyContent(replyContent + e.native)}
                    title="Emojis"
                  />
                </div>
              )}

              <input
                type="text"
                value={replyContent}
                onChange={(e) => setReplyContent(e.target.value)}
                placeholder="Vi·∫øt tr·∫£ l·ªùi..."
                className="flex-1 text-sm outline-none border rounded-l-lg px-2 py-1"
                required
                onFocus={() => setShowEmojis(false)}
              />
              <button
                type="submit"
                className={`${replyContent.trim().length < 1 || isSubmitting ? "text-blue-300" : "text-white bg-primary-blue"} text-sm font-semibold px-2 rounded-r-lg`}
                disabled={replyContent.trim().length < 1 || isSubmitting}
              >
                {isSubmitting ? "ƒêang g·ª≠i..." : "G·ª≠i"}
              </button>
            </form>
          )}
        </div>
      </div>

      {loadingChildren && (
        <div className="mt-2 text-gray-500 text-sm pl-9">
          ƒêang t·∫£i b√¨nh lu·∫≠n...
        </div>
      )}

      {/* Hi·ªÉn th·ªã b√¨nh lu·∫≠n con v·ªõi ƒë∆∞·ªùng vi·ªÅn r√µ r√†ng */}
      {showChildComments && childComments.length > 0 && (
        <div className="mt-2">
          {childComments.map((childComment) => (
            <CommentItem
              key={`comment-${childComment._id}-${level}`}
              comment={childComment}
              postId={postId}
              level={level + 1}
              onReplySubmit={onReplySubmit}
              onCommentDeleted={onCommentDeleted}
            />
          ))}
        </div>
      )}
    </div>
  );
};

// Component PostItem ch√≠nh
const PostItem = ({
  _id,
  caption,
  likes,
  comments,
  image,
  postedBy,
  savedBy,
  createdAt,
  setUsersDialog,
  setUsersList,
}) => {
  const dispatch = useDispatch();
  const commentInput = useRef(null);

  const { user } = useSelector((state) => state.user);

  const [allLikes, setAllLikes] = useState(likes);
  const [hierarchicalComments, setHierarchicalComments] = useState([]);
  const [allSavedBy, setAllSavedBy] = useState(savedBy);
  const { socket } = useContext(AppContext);
  const [deleteModal, setDeleteModal] = useState(false);
  const [liked, setLiked] = useState(false);
  const [saved, setSaved] = useState(false);
  const [comment, setComment] = useState("");
  const [viewComment, setViewComment] = useState(false);
  const [showEmojis, setShowEmojis] = useState(false);
  const [commentsLoading, setCommentsLoading] = useState(false);
  const [commentCount, setCommentCount] = useState(0);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const [likeEffect, setLikeEffect] = useState(false);

  // Ki·ªÉm tra k·∫øt n·ªëi socket khi component mount
  useEffect(() => {
    if (socket && socket.current) {
      console.log("Socket ƒë√£ k·∫øt n·ªëi:", socket.current.connected);

      if (!socket.current.connected) {
        console.log("Socket ch∆∞a k·∫øt n·ªëi, ƒëang th·ª≠ k·∫øt n·ªëi l·∫°i...");
        socket.current.connect();
      }
    } else {
      console.log("Socket ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o");
    }
  }, [socket]);

  // T·∫£i b√¨nh lu·∫≠n t·ª´ API khi m·ªü xem b√¨nh lu·∫≠n
  useEffect(() => {
    if (viewComment) {
      loadComments();
    }
  }, [viewComment]);

  // T·∫£i s·ªë l∆∞·ª£ng b√¨nh lu·∫≠n khi component mount
  useEffect(() => {
    fetchCommentCount();
  }, [_id]);

  // T·∫£i s·ªë l∆∞·ª£ng b√¨nh lu·∫≠n
  const fetchCommentCount = async () => {
    try {
      const response = await axios.get(`/api/v1/comments/${_id}/count`);
      if (response.data.success) {
        setCommentCount(response.data.count);
      }
    } catch (error) {
      console.error("L·ªói khi t·∫£i s·ªë l∆∞·ª£ng b√¨nh lu·∫≠n:", error);
    }
  };

  // T·∫£i b√¨nh lu·∫≠n g·ªëc (kh√¥ng c√≥ parent)
  const loadComments = async () => {
    setCommentsLoading(true);
    try {
      console.log("ƒêang t·∫£i b√¨nh lu·∫≠n g·ªëc cho b√†i ƒëƒÉng:", _id);
      const response = await axios.get(`/api/v1/comments/${_id}/parent`);
      if (response.data.success) {
        console.log("B√¨nh lu·∫≠n g·ªëc nh·∫≠n ƒë∆∞·ª£c:", response.data.comments);

        // L·ªçc b·ªè b√¨nh lu·∫≠n tr√πng l·∫∑p
        const uniqueComments = [];
        const commentIds = new Set();

        response.data.comments.forEach((comment) => {
          if (!commentIds.has(comment._id)) {
            commentIds.add(comment._id);
            uniqueComments.push(comment);
          }
        });

        setHierarchicalComments(uniqueComments);
      }
    } catch (error) {
      console.error("L·ªói khi t·∫£i b√¨nh lu·∫≠n:", error);
    } finally {
      setCommentsLoading(false);
    }
  };

  // X·ª≠ l√Ω khi m·ªôt b√¨nh lu·∫≠n b·ªã x√≥a
  const handleCommentDeleted = (commentId) => {
    console.log("B√¨nh lu·∫≠n ƒë√£ b·ªã x√≥a:", commentId);

    // X√≥a b√¨nh lu·∫≠n kh·ªèi danh s√°ch hi·ªán t·∫°i
    setHierarchicalComments((prevComments) =>
      prevComments.filter((comment) => comment._id !== commentId),
    );

    // Gi·∫£m s·ªë l∆∞·ª£ng b√¨nh lu·∫≠n
    setCommentCount((prev) => Math.max(0, prev - 1));

    // T·∫£i l·∫°i b√¨nh lu·∫≠n sau khi x√≥a
    fetchCommentCount();
  };

  // L·∫Øng nghe s·ª± ki·ªán updatePost t·ª´ Socket.IO
  useEffect(() => {
    if (!socket || !socket.current) return;

    const handlePostUpdate = (data) => {
      console.log("Nh·∫≠n s·ª± ki·ªán updatePost:", data);

      if (data.action === "like" && data.data && data.data.post) {
        setAllLikes(data.data.post.likes);
      } else if (data.action === "comment") {
        // Khi c√≥ b√¨nh lu·∫≠n m·ªõi, c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng b√¨nh lu·∫≠n v√† t·∫£i l·∫°i n·∫øu ƒëang xem
        fetchCommentCount();
        if (viewComment) {
          loadComments();
        }
      }
    };

    socket.current.on("updatePost", handlePostUpdate);

    return () => {
      socket.current.off("updatePost", handlePostUpdate);
    };
  }, [socket, viewComment, _id]);

  // X·ª≠ l√Ω like/unlike b√†i ƒëƒÉng
  const handleLike = async () => {
    const wasLiked = liked; // L∆∞u tr·∫°ng th√°i tr∆∞·ªõc khi c·∫≠p nh·∫≠t UI
    setLiked(!liked); // C·∫≠p nh·∫≠t UI ngay l·∫≠p t·ª©c

    try {
      await dispatch(likePost(_id));
      const { data } = await axios.get(`/api/v1/post/detail/${_id}`);
      setAllLikes(data.post.likes);

      // G·ª≠i th√¥ng b√°o qua socket.io
      if (socket?.current && socket.current.connected) {
        // Th√™m th√¥ng tin ng∆∞·ªùi like
        const postData = {
          ...data,
          likerId: user._id,
          likerName: user.username || user.name,
        };

        socket.current.emit("likePost", postData);
        console.log("ƒê√£ g·ª≠i s·ª± ki·ªán likePost:", postData);
      } else {
        console.log("Socket kh√¥ng kh·∫£ d·ª•ng ho·∫∑c kh√¥ng k·∫øt n·ªëi");
      }
    } catch (error) {
      // N·∫øu c√≥ l·ªói, ho√†n t√°c UI
      setLiked(wasLiked);
      console.error("L·ªói khi c·∫≠p nh·∫≠t like:", error);
    }
  };

  // G·ª≠i b√¨nh lu·∫≠n m·ªõi (kh√¥ng c√≥ parent)
  const handleComment = async (e) => {
    e.preventDefault();

    if (!comment.trim() || isSubmitting) {
      return;
    }

    setIsSubmitting(true);

    try {
      console.log("G·ª≠i b√¨nh lu·∫≠n m·ªõi:", {
        postId: _id,
        content: comment,
        parentCommentId: null,
      });

      // Th√™m c√°c th√¥ng tin debug ƒë·ªÉ xem request
      console.log("URL API:", `/api/v1/post/${_id}/comment`);

      // G·ªçi API ƒë·ªÉ t·∫°o comment
      const response = await axios({
        method: "post",
        url: `/api/v1/post/${_id}/comment`,
        data: {
          content: comment,
          parentCommentId: null,
        },
        // Th√™m header ƒë·ªÉ d·ªÖ debug
        headers: {
          "Content-Type": "application/json",
        },
      });

      console.log("K·∫øt qu·∫£ g·ª≠i b√¨nh lu·∫≠n:", response.data);

      // X√≥a n·ªôi dung input
      setComment("");

      // T·∫£i l·∫°i b√¨nh lu·∫≠n v√† s·ªë l∆∞·ª£ng
      fetchCommentCount();
      if (viewComment) {
        // Th√™m timeout ƒë·ªÉ ƒë·∫£m b·∫£o server ƒë√£ x·ª≠ l√Ω xong
        setTimeout(() => {
          loadComments();
        }, 500);
      }

      // Emit s·ª± ki·ªán socket n·∫øu socket kh·∫£ d·ª•ng
      if (socket?.current && socket.current.connected) {
        console.log("Emit s·ª± ki·ªán commentPost");

        socket.current.emit("commentPost", {
          post: {
            _id: _id,
            postedBy: postedBy._id,
          },
          comment: response.data.comment,
          commenterId: user._id,
          commenterName: user.username || user.name,
        });
      } else {
        console.log(
          "Socket kh√¥ng kh·∫£ d·ª•ng ho·∫∑c kh√¥ng k·∫øt n·ªëi, kh√¥ng th·ªÉ emit s·ª± ki·ªán",
        );
      }
    } catch (error) {
      console.error("L·ªói khi g·ª≠i b√¨nh lu·∫≠n:", error);
      // Th√™m th√¥ng tin chi ti·∫øt v·ªÅ l·ªói
      if (error.response) {
        console.error(
          "L·ªói response:",
          error.response.status,
          error.response.data,
        );
      }
    } finally {
      setIsSubmitting(false);
    }
  };
  // X·ª≠ l√Ω tr·∫£ l·ªùi b√¨nh lu·∫≠n
  const handleReplySubmit = async (content, parentId) => {
    if (!content.trim()) return false;

    try {
      console.log("G·ª≠i b√¨nh lu·∫≠n tr·∫£ l·ªùi:", {
        postId: _id,
        content: content,
        parentCommentId: parentId,
      });

      const response = await axios.post(`/api/v1/post/${_id}/comment`, {
        content,
        parentCommentId: parentId,
      });

      console.log("K·∫øt qu·∫£ tr·∫£ l·ªùi:", response.data);

      // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng b√¨nh lu·∫≠n
      fetchCommentCount();

      // G·ª≠i th√¥ng b√°o v·ªÅ tr·∫£ l·ªùi b√¨nh lu·∫≠n qua socket
      if (socket?.current && socket.current.connected) {
        try {
          // T√¨m th√¥ng tin v·ªÅ comment g·ªëc
          const parentCommentResponse = await axios.get(
            `/api/v1/comment/${parentId}`,
          );

          if (
            parentCommentResponse.data &&
            parentCommentResponse.data.comment
          ) {
            const parentComment = parentCommentResponse.data.comment;
            const parentCommentOwnerId =
              parentComment.comment_userId._id || parentComment.comment_userId;

            // Ch·ªâ g·ª≠i th√¥ng b√°o n·∫øu ng∆∞·ªùi tr·∫£ l·ªùi kh√¥ng ph·∫£i l√† ch·ªß b√¨nh lu·∫≠n g·ªëc
            if (parentCommentOwnerId !== user._id) {
              socket.current.emit("replyComment", {
                commentId: response.data.comment._id,
                postId: _id,
                parentCommentId: parentId,
                replierId: user._id,
                parentCommentOwnerId: parentCommentOwnerId,
                replierName: user.username || user.name,
              });

              console.log("ƒê√£ g·ª≠i s·ª± ki·ªán replyComment");
            }
          }
        } catch (error) {
          console.error("L·ªói khi l·∫•y th√¥ng tin comment g·ªëc:", error);
        }
      } else {
        console.log(
          "Socket kh√¥ng kh·∫£ d·ª•ng ho·∫∑c kh√¥ng k·∫øt n·ªëi, kh√¥ng th·ªÉ emit s·ª± ki·ªán",
        );
      }

      return true;
    } catch (error) {
      console.error("L·ªói khi g·ª≠i tr·∫£ l·ªùi:", error);
      return false;
    }
  };

  const handleSave = async () => {
    setSaved(!saved);
    await dispatch(savePost(_id));
    const { data } = await axios.get(`/api/v1/post/detail/${_id}`);
    setAllSavedBy(data.post.savedBy);
  };

  const handleLikeModal = () => {
    setUsersDialog(true);
    setUsersList(allLikes);
  };

  const handleDeletePost = () => {
    dispatch(deletePost(_id, true));
    setDeleteModal(false);
  };

  const setLike = () => {
    setLikeEffect(true);
    setTimeout(() => {
      setLikeEffect(false);
    }, 500);
    if (liked) {
      return;
    }
    handleLike();
  };

  const closeDeleteModal = () => {
    setDeleteModal(false);
  };

  useEffect(() => {
    setLiked(allLikes.some((u) => u._id === user._id));
  }, [allLikes, user._id]);

  useEffect(() => {
    setSaved(allSavedBy.some((id) => id === user._id));
  }, [allSavedBy, user._id]);

  return (
    <div className="flex flex-col border rounded bg-white relative">
      {/* Header ph·∫ßn */}
      <div className="flex justify-between px-3 py-2.5 border-b items-center">
        <div className="flex space-x-3 items-center">
          <Link to={`/${postedBy.username}`}>
            <img
              draggable="false"
              className="w-10 h-10 rounded-full object-cover"
              src={BASE_PROFILE_IMAGE_URL + postedBy.avatar}
              alt="avatar"
            />
          </Link>
          <Link
            to={`/${postedBy.username}`}
            className="text-black text-sm font-semibold"
          >
            {postedBy.username}
          </Link>
        </div>
        <span onClick={() => setDeleteModal(true)} className="cursor-pointer">
          {moreIcons}
        </span>

        <Dialog open={deleteModal} onClose={closeDeleteModal} maxWidth="xl">
          <div className="flex flex-col items-center w-80">
            {postedBy._id === user._id && (
              <button
                onClick={handleDeletePost}
                className="text-red-600 font-medium border-b py-2.5 w-full hover:bg-red-50"
              >
                X√≥a
              </button>
            )}
            <button
              onClick={closeDeleteModal}
              className="py-2.5 w-full hover:bg-gray-50"
            >
              H·ªßy
            </button>
          </div>
        </Dialog>
      </div>

      {/* Ph·∫ßn ·∫£nh b√†i ƒëƒÉng */}
      <div
        className="relative flex items-center justify-center"
        onDoubleClick={setLike}
      >
        <img
          draggable="false"
          loading="lazy"
          className="w-full h-full object-cover object-center"
          src={BASE_POST_IMAGE_URL + image}
          alt="post image"
        />
        {likeEffect && (
          <img
            draggable="false"
            height="80px"
            className="likeEffect"
            alt="heart"
            src="https://img.icons8.com/ios-filled/2x/ffffff/like.png"
          />
        )}
      </div>

      {/* Ph·∫ßn n√∫t like, b√¨nh lu·∫≠n v√† caption */}
      <div className="flex flex-col px-4 space-y-1 border-b pb-2 mt-2">
        {/* C√°c n√∫t t∆∞∆°ng t√°c */}
        <div className="flex items-center justify-between py-2">
          <div className="flex space-x-4">
            <button onClick={handleLike}>
              {liked ? likeFill : likeIconOutline}
            </button>
            <button onClick={() => commentInput.current.focus()}>
              {commentIcon}
            </button>
            {shareIcon}
          </div>
          <button onClick={handleSave}>
            {saved ? saveIconFill : saveIconOutline}
          </button>
        </div>

        {/* S·ªë l∆∞·ª£t th√≠ch */}
        <span
          onClick={handleLikeModal}
          className="font-semibold text-sm cursor-pointer"
        >
          {allLikes.length} l∆∞·ª£t th√≠ch
        </span>

        {/* Caption */}
        <div className="flex flex-auto items-center space-x-1">
          <Link
            to={`/${postedBy.username}`}
            className="text-sm font-semibold hover:underline"
          >
            {postedBy.username}
          </Link>
          <span className="text-sm">{caption}</span>
        </div>

        {/* S·ªë l∆∞·ª£ng b√¨nh lu·∫≠n v√† th·ªùi gian */}
        {commentCount > 0 ? (
          <span
            onClick={() => setViewComment(!viewComment)}
            className="text-[13px] text-gray-500 cursor-pointer"
          >
            {viewComment
              ? "·∫®n b√¨nh lu·∫≠n"
              : commentCount === 1
                ? `Xem ${commentCount} b√¨nh lu·∫≠n`
                : `Xem t·∫•t c·∫£ ${commentCount} b√¨nh lu·∫≠n`}
          </span>
        ) : (
          <span className="text-[13px] text-gray-500">
            Ch∆∞a c√≥ b√¨nh lu·∫≠n n√†o!
          </span>
        )}
        <span className="text-xs text-gray-500 cursor-pointer">
          {moment(createdAt).fromNow()}
        </span>

        {/* Ph·∫ßn hi·ªÉn th·ªã b√¨nh lu·∫≠n */}
        {viewComment && (
          <ScrollToBottom className="w-full h-52 overflow-y-auto py-1">
            {commentsLoading ? (
              <div className="text-center py-4 text-gray-500">
                ƒêang t·∫£i b√¨nh lu·∫≠n...
              </div>
            ) : hierarchicalComments.length > 0 ? (
              hierarchicalComments.map((comment) => (
                <CommentItem
                  key={`root-comment-${comment._id}`}
                  comment={comment}
                  postId={_id}
                  onReplySubmit={handleReplySubmit}
                  onCommentDeleted={handleCommentDeleted}
                />
              ))
            ) : (
              <div className="text-center py-4 text-gray-500">
                Ch∆∞a c√≥ b√¨nh lu·∫≠n n√†o!
              </div>
            )}
          </ScrollToBottom>
        )}
      </div>

      {/* Form nh·∫≠p b√¨nh lu·∫≠n */}
      <form
        onSubmit={handleComment}
        className="flex items-center justify-between p-3 w-full space-x-3"
      >
        <span
          onClick={() => setShowEmojis(!showEmojis)}
          className="cursor-pointer"
        >
          {emojiIcon}
        </span>

        {showEmojis && (
          <div className="absolute bottom-12 -left-2 z-10">
            <Picker
              set="google"
              onSelect={(e) => setComment(comment + e.native)}
              title="Emojis"
            />
          </div>
        )}

        <input
          className="flex-auto text-sm outline-none border-none bg-transparent"
          type="text"
          value={comment}
          ref={commentInput}
          required
          onFocus={() => setShowEmojis(false)}
          onChange={(e) => setComment(e.target.value)}
          placeholder="Th√™m b√¨nh lu·∫≠n..."
        />
        <button
          type="submit"
          className={`${comment.trim().length < 1 || isSubmitting ? "text-blue-300" : "text-primary-blue"} text-sm font-semibold`}
          disabled={comment.trim().length < 1 || isSubmitting}
        >
          {isSubmitting ? "ƒêang g·ª≠i..." : "ƒêƒÉng"}
        </button>
      </form>
    </div>
  );
};

export default PostItem;
